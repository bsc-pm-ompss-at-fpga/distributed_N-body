///////////////////
// Automatic IP Generated by OmpSs@FPGA compiler
///////////////////
// The below code is composed by:
//  1) User source code, which may be under any license (see in original source code)
//  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
///////////////////
// Top IP Function: calc_forces
// Accel. type hash: 4294967297
// Num. instances: 1
// Wrapper version: 13
///////////////////

//#include "src/blocking/fpga_distributed/nbody.fpga.h"
#include <hls_stream.h>
#include <hls_math.h>
#include <ap_int.h>
#include <ap_axi_sdata.h>

static ap_uint<64> __mcxx_taskId;
template<class T>
union __mcxx_cast {
   unsigned long long int raw;
   T typed;
};
struct mcxx_inaxis {
   ap_uint<64> data;
};

typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;

void mcxx_set_lock(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort);
void mcxx_unset_lock(hls::stream<mcxx_outaxis>& mcxx_outPort);

static constexpr unsigned int NCALCFORCES = 16;
static constexpr unsigned int FPGA_PWIDTH = 128;
static constexpr int BLOCK_SIZE = 2048;
static void calculate_forces_block_moved(float x [BLOCK_SIZE], float y[BLOCK_SIZE], float z[BLOCK_SIZE], const float pos_x1[BLOCK_SIZE], const float pos_y1[BLOCK_SIZE], const float pos_z1[BLOCK_SIZE], const float mass1[BLOCK_SIZE], const float pos_x2[BLOCK_SIZE], const float pos_y2[BLOCK_SIZE], const float pos_z2[BLOCK_SIZE], const float weight2[BLOCK_SIZE])
{
#pragma HLS inline
#pragma HLS array_partition variable=x cyclic factor=NCALCFORCES
#pragma HLS array_partition variable=y cyclic factor=NCALCFORCES
#pragma HLS array_partition variable=z cyclic factor=NCALCFORCES
#pragma HLS array_partition variable=pos_x1 cyclic factor=NCALCFORCES/2
#pragma HLS array_partition variable=pos_y1 cyclic factor=NCALCFORCES/2
#pragma HLS array_partition variable=pos_z1 cyclic factor=NCALCFORCES/2
#pragma HLS array_partition variable=mass1 cyclic factor=NCALCFORCES/2
#pragma HLS array_partition variable=pos_x2 cyclic factor=FPGA_PWIDTH/64
#pragma HLS array_partition variable=pos_y2 cyclic factor=FPGA_PWIDTH/64
#pragma HLS array_partition variable=pos_z2 cyclic factor=FPGA_PWIDTH/64
#pragma HLS array_partition variable=weight2 cyclic factor=FPGA_PWIDTH/64
	//for (int i=0 ; i < 2048; i++)
      main_loop: for (int l = 0; l < 2048*2048; l++)
        {
//#pragma HLS loop_flatten
#pragma HLS pipeline II=1
#pragma HLS unroll factor=NCALCFORCES
          const float diff_x = pos_x2[l/2048] - pos_x1[l%2048];
          const float diff_y = pos_y2[l/2048] - pos_y1[l%2048];
          const float diff_z = pos_z2[l/2048] - pos_z1[l%2048];
          const float distance_squared = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;
          //const float distance = sqrtf(distance_squared);
          //const float force = mass1[j] / (distance_squared * distance) * weight2[i];
          const float inv_dist = hls::rsqrtf(distance_squared);
          const float force = mass1[l%2048] / distance_squared * inv_dist * weight2[l/2048];
          const float force_corrected = distance_squared == 0 ? 0 : force;
          x[l%2048] += force_corrected * diff_x;
          y[l%2048] += force_corrected * diff_y;
          z[l%2048] += force_corrected * diff_z;
        }
}

void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   mcxx_outaxis axis_word;
   axis_word.data = data;
   axis_word.dest = dest;
   axis_word.last = last;
   mcxx_outPort.write(axis_word);
}
void calc_forces_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, ap_uint<128>* mcxx_memport) {
#pragma HLS interface ap_ctrl_none port=return
#pragma HLS interface axis port=mcxx_inPort
#pragma HLS interface axis port=mcxx_outPort
#pragma HLS interface m_axi port=mcxx_memport
   static float weight2[2048L];
   static float pos_x1[2048L];
   static float pos_y2[2048L];
   static float pos_z1[2048L];
   static float y[2048L];
   static float pos_z2[2048L];
   static float pos_y1[2048L];
   static float x[2048L];
   static float mass1[2048L];
   static float z[2048L];
   static float pos_x2[2048L];
   mcxx_inPort.read(); //command word
   __mcxx_taskId = mcxx_inPort.read();
   ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
   ap_uint<8> mcxx_flags_0;
   ap_uint<64> mcxx_offset_0;
   ap_uint<8> mcxx_flags_1;
   ap_uint<64> mcxx_offset_1;
   ap_uint<8> mcxx_flags_2;
   ap_uint<64> mcxx_offset_2;
   ap_uint<8> mcxx_flags_3;
   ap_uint<64> mcxx_offset_3;
   ap_uint<8> mcxx_flags_4;
   ap_uint<64> mcxx_offset_4;
   ap_uint<8> mcxx_flags_5;
   ap_uint<64> mcxx_offset_5;
   ap_uint<8> mcxx_flags_6;
   ap_uint<64> mcxx_offset_6;
   ap_uint<8> mcxx_flags_7;
   ap_uint<64> mcxx_offset_7;
   ap_uint<8> mcxx_flags_8;
   ap_uint<64> mcxx_offset_8;
   ap_uint<8> mcxx_flags_9;
   ap_uint<64> mcxx_offset_9;
   ap_uint<8> mcxx_flags_10;
   ap_uint<64> mcxx_offset_10;
   {
      #pragma HLS protocol fixed
      {
         mcxx_flags_0 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_0 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_1 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_1 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_2 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_2 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_3 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_3 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_4 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_4 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_5 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_5 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_6 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_6 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_7 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_7 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_8 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_8 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_9 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_9 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_10 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_10 = mcxx_inPort.read();
      }
      ap_wait();
   }
   //mcxx_set_lock(mcxx_inPort, mcxx_outPort);
   if (mcxx_flags_10[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_10/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            weight2[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_3[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_3/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            pos_x1[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_8[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_8/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            pos_y2[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_5[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_5/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            pos_z1[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_1[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_1/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            y[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_9[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_9/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            pos_z2[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_4[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_4/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            pos_y1[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_0[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            x[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_6[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_6/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            mass1[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_2[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_2/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            z[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_7[4]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_7/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            pos_x2[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   //mcxx_unset_lock(mcxx_outPort);
   calculate_forces_block_moved(x, y, z, pos_x1, pos_y1, pos_z1, mass1, pos_x2, pos_y2, pos_z2, weight2);
   //mcxx_set_lock(mcxx_inPort, mcxx_outPort);
   if (mcxx_flags_1[5]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = y[__i*(sizeof(ap_uint<128>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_1/sizeof(ap_uint<128>)+ __i) = __tmpBuffer;
      }
   }
   if (mcxx_flags_0[5]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = x[__i*(sizeof(ap_uint<128>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<128>)+ __i) = __tmpBuffer;
      }
   }
   if (mcxx_flags_2[5]) {
      for (int __i = 0; __i < (((4L) * (2048L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = z[__i*(sizeof(ap_uint<128>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_2/sizeof(ap_uint<128>)+ __i) = __tmpBuffer;
      }
   }
   //mcxx_unset_lock(mcxx_outPort);
   {
      #pragma HLS protocol fixed
      ap_uint<64> header = 0x03;
      ap_wait();
      mcxx_write_out_port(header, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
      ap_wait();
   }
}

void mcxx_set_lock(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   ap_uint<64> tmp = 0x4;
   ap_uint<8> ack;
   do {
      ap_wait();
      mcxx_write_out_port(tmp, 1, 1, mcxx_outPort);
      ap_wait();
      ack = mcxx_inPort.read();
      ap_wait();
   } while (ack == 0);
}

void mcxx_unset_lock(hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   ap_uint<64> tmp = 0x6;
   mcxx_write_out_port(tmp, 1, 1, mcxx_outPort);
}
