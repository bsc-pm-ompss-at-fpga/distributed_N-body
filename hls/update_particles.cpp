///////////////////
// Automatic IP Generated by OmpSs@FPGA compiler
///////////////////
// The below code is composed by:
//  1) User source code, which may be under any license (see in original source code)
//  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
///////////////////
// Top IP Function: update_particles
// Accel. type hash: 4294967298
// Num. instances: 1
// Wrapper version: 13
///////////////////

#include <hls_stream.h>
#include <ap_int.h>
#include <ap_axi_sdata.h>

static ap_uint<64> __mcxx_taskId;
template<class T>
union __mcxx_cast {
   unsigned long long int raw;
   T typed;
};
struct mcxx_inaxis {
   ap_uint<64> data;
};

typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;

void mcxx_set_lock(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort);
void mcxx_unset_lock(hls::stream<mcxx_outaxis>& mcxx_outPort);

static const unsigned int FPGA_PWIDTH = 128;
static const unsigned int PARTICLES_FPGABLOCK_POS_X_OFFSET = 0 * 2048;
static const unsigned int PARTICLES_FPGABLOCK_POS_Y_OFFSET = 1 * 2048;
static const unsigned int PARTICLES_FPGABLOCK_POS_Z_OFFSET = 2 * 2048;
static const unsigned int PARTICLES_FPGABLOCK_VEL_X_OFFSET = 3 * 2048;
static const unsigned int PARTICLES_FPGABLOCK_VEL_Y_OFFSET = 4 * 2048;
static const unsigned int PARTICLES_FPGABLOCK_VEL_Z_OFFSET = 5 * 2048;
static const unsigned int PARTICLES_FPGABLOCK_MASS_OFFSET = 6 * 2048;
static const unsigned int FORCE_FPGABLOCK_X_OFFSET = 0 * 2048;
static const unsigned int FORCE_FPGABLOCK_Y_OFFSET = 1 * 2048;
static const unsigned int FORCE_FPGABLOCK_Z_OFFSET = 2 * 2048;
static void update_particles_block_moved(float particles[16384L], float forces[6144L], const float time_interval)
{
#pragma HLS inline
#pragma HLS array_partition variable=forces cyclic factor=FPGA_PWIDTH/64
#pragma HLS array_partition variable=particles cyclic factor=FPGA_PWIDTH/64
  for (int e = 0; e < 2048; e++)
    {
#pragma HLS pipeline II=7
#pragma HLS dependence variable=particles inter false
#pragma HLS dependence variable=forces inter false
      const float mass = particles[PARTICLES_FPGABLOCK_MASS_OFFSET + e];
      const float velocity_x = particles[PARTICLES_FPGABLOCK_VEL_X_OFFSET + e];
      const float velocity_y = particles[PARTICLES_FPGABLOCK_VEL_Y_OFFSET + e];
      const float velocity_z = particles[PARTICLES_FPGABLOCK_VEL_Z_OFFSET + e];
      const float position_x = particles[PARTICLES_FPGABLOCK_POS_X_OFFSET + e];
      const float position_y = particles[PARTICLES_FPGABLOCK_POS_Y_OFFSET + e];
      const float position_z = particles[PARTICLES_FPGABLOCK_POS_Z_OFFSET + e];
      const float time_by_mass = time_interval / mass;
      const float half_time_interval = 5.000000000000000000000000e-01f * time_interval;
      const float velocity_change_x = forces[FORCE_FPGABLOCK_X_OFFSET + e] * time_by_mass;
      const float velocity_change_y = forces[FORCE_FPGABLOCK_Y_OFFSET + e] * time_by_mass;
      const float velocity_change_z = forces[FORCE_FPGABLOCK_Z_OFFSET + e] * time_by_mass;
      const float position_change_x = velocity_x * time_interval + velocity_change_x * half_time_interval;
      const float position_change_y = velocity_y * time_interval + velocity_change_y * half_time_interval;
      const float position_change_z = velocity_z * time_interval + velocity_change_z * half_time_interval;
      particles[PARTICLES_FPGABLOCK_VEL_X_OFFSET + e] = velocity_x + velocity_change_x;
      particles[PARTICLES_FPGABLOCK_VEL_Y_OFFSET + e] = velocity_y + velocity_change_y;
      particles[PARTICLES_FPGABLOCK_VEL_Z_OFFSET + e] = velocity_z + velocity_change_z;
      particles[PARTICLES_FPGABLOCK_POS_X_OFFSET + e] = position_x + position_change_x;
      particles[PARTICLES_FPGABLOCK_POS_Y_OFFSET + e] = position_y + position_change_y;
      particles[PARTICLES_FPGABLOCK_POS_Z_OFFSET + e] = position_z + position_change_z;
      forces[FORCE_FPGABLOCK_X_OFFSET + e] = 0.000000000000000000000000e+00f;
      forces[FORCE_FPGABLOCK_Y_OFFSET + e] = 0.000000000000000000000000e+00f;
      forces[FORCE_FPGABLOCK_Z_OFFSET + e] = 0.000000000000000000000000e+00f;
    }
}

void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   mcxx_outaxis axis_word;
   axis_word.data = data;
   axis_word.dest = dest;
   axis_word.last = last;
   mcxx_outPort.write(axis_word);
}
void update_particles_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, ap_uint<128>* mcxx_memport) {
#pragma HLS interface ap_ctrl_none port=return
#pragma HLS interface axis port=mcxx_inPort
#pragma HLS interface axis port=mcxx_outPort
#pragma HLS interface m_axi port=mcxx_memport
   static float forces[6144L];
   static float particles[16384L];
   mcxx_inPort.read(); //command word
   __mcxx_taskId = mcxx_inPort.read();
   ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
   ap_uint<8> mcxx_flags_0;
   ap_uint<64> mcxx_offset_0;
   ap_uint<8> mcxx_flags_1;
   ap_uint<64> mcxx_offset_1;
   float time_interval;
   {
      #pragma HLS protocol fixed
      {
         mcxx_flags_0 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_0 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_1 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_1 = mcxx_inPort.read();
      }
      ap_wait();
      {
         ap_uint<8> mcxx_flags_2;
         ap_uint<64> mcxx_offset_2;
         mcxx_flags_2 = mcxx_inPort.read()(7,0);
         ap_wait();
         __mcxx_cast<float> mcxx_arg_2;
         mcxx_arg_2.raw = mcxx_inPort.read();
         time_interval = mcxx_arg_2.typed;
      }
      ap_wait();
   }
   //mcxx_set_lock(mcxx_inPort, mcxx_outPort);
   if (mcxx_flags_1[4]) {
      for (int __i = 0; __i < (((4L) * (6144L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_1/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            forces[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_0[4]) {
      for (int __i = 0; __i < (((4L) * (16384L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<128>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            particles[__i*(sizeof(ap_uint<128>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   //mcxx_unset_lock(mcxx_outPort);
   update_particles_block_moved(particles, forces, time_interval);
   //mcxx_set_lock(mcxx_inPort, mcxx_outPort);
   if (mcxx_flags_1[5]) {
      for (int __i = 0; __i < (((4L) * (6144L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = forces[__i*(sizeof(ap_uint<128>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_1/sizeof(ap_uint<128>)+ __i) = __tmpBuffer;
      }
   }
   if (mcxx_flags_0[5]) {
      for (int __i = 0; __i < (((4L) * (16384L)) - 1)/sizeof(ap_uint<128>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<128> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<128>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = particles[__i*(sizeof(ap_uint<128>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<128>)+ __i) = __tmpBuffer;
      }
   }
   //mcxx_unset_lock(mcxx_outPort);
   {
      #pragma HLS protocol fixed
      ap_uint<64> header = 0x03;
      ap_wait();
      mcxx_write_out_port(header, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
      ap_wait();
   }
}

void mcxx_set_lock(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   ap_uint<64> tmp = 0x4;
   ap_uint<8> ack;
   do {
      ap_wait();
      mcxx_write_out_port(tmp, 1, 1, mcxx_outPort);
      ap_wait();
      ack = mcxx_inPort.read();
      ap_wait();
   } while (ack == 0);
}

void mcxx_unset_lock(hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   ap_uint<64> tmp = 0x6;
   mcxx_write_out_port(tmp, 1, 1, mcxx_outPort);
}
